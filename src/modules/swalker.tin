#CLASS {RL_SWALKER} {kill};
#CLASS {RL_SWALKER} {open};


/**********************************************************************************************************************
 * Module RL_SWALKER                                                                                               *
 *                                                                                                                    *
 * Runs -hidden-  automatically through straight paths                                                                          *
 **********************************************************************************************************************/

/register_module {RL_SWALKER} {srumbo} {Recorrido automático de caminos (como el comando galopar).};
/add_module_setting {RL_SWALKER} {delay} {number} {} {1} {Segundos entre dirección y dirección};

/**********************************************************************************************************************
 * Aliases                                                                                                            *
 **********************************************************************************************************************/

/*
 * Alias /srumbo {direction|off}
 *
 * Walks a straight path towards the given direction, cloaked
 *
 * Arguments:
 *   %1 (any) direction|off
 *
 * Example:
 *   /srumbo {e};
 */
#ALIAS {/srumbo} {
    #CLASS {RL_SWALKER_IMPL} {open};
    #IF {"%1" == ""} {
        /message {Sintáxis: /ssrumbo <dirección|off>};
        #RETURN;
    };
    #ALIAS {/limpiar_srumbo} {
        #CLASS {RL_SWALKER_IMPL} {kill};
        /message {%%1};
        #UNVAR {lastVisitedExit};
        #UNVAR {exits};
        #UNDELAY {pathwalker_movement};
        #UNALIAS {/limpiar_srumbo};
    };
    #IF {"%1" == "off"} {
        /limpiar_srumbo {srumbo detenido.};
        #RETURN;
    };
    #VAR {lastVisitedExit} {@opposite_direction{%1}};
    #ACT {^%%* [{[noseabdr,|]+[noseabdr|]*}]{[ ]*}$} {
        #VAR {exits} {%%2};
        #REPLACE {exits} {,} {;};
        #LIST {exits} {create} {$exits};
        #LIST {exits} {size} {exitsLength};
        #IF {$exitsLength > 2} {
            /limpiar_srumbo {Has llegado a una bifurcación en el camino.};
        };
        #ELSEIF {$exitsLength < 2} {
            /limpiar_srumbo {Has llegado a un callejón sin salida.};
        };
        #ELSE {
            #FOREACH {$exits[%%*]} {exit} {
                #IF {"$exit" != "$lastVisitedExit"} {
                    #VAR {lastVisitedExit} {@opposite_direction{$exit}};
                    #DELAY {pathwalker_movement} {$exit} {@get_module_setting_value{RL_SWALKER;delay}};
                    #BREAK;
                };
            };
        };
    };
    #ACT {^Parece que %* no produjo efecto alguno.$} {
        /limpiar_srumbo {Deteniendo el srumbo, pues algo raro ha sucedido.};
    };
    /message {Sigilando srumbo %1...};
    #SEND {sigilar %1};
    #CLASS {RL_SWALKER_IMPL} {close};
}

/**********************************************************************************************************************
 * Autocompletion                                                                                                     *
 **********************************************************************************************************************/

#TAB {/srumbo};

/**********************************************************************************************************************
 * Testing                                                                                                            *
 **********************************************************************************************************************/

#IF {$_development == 1} {
    #ALIAS {/test_RL_SWALKER} {
        #SHOWME {No tests implemented.};
    };
};

#CLASS {RL_SWALKER} {close};
